name: (template) Rancher Backup-Restore E2E tests

on:
  workflow_call:
    secrets:
      aws_access_key:
        description: AWS_ACCESS_KEY_ID required to create AWS Cloud credentials.
        required: true
      aws_secret_key:
        description: AWS_SECRET_ACCESS_KEY required to create AWS Cloud credentials.
        required: true
      rancher_password:
        description: Rancher login password
        required: true
      instance_ssh_key:
        description: SSH private key for EC2 instance access.
        required: true
      aws_region:
        description: AWS region where the EC2 instance will be created.
        required: true
      key_name:
        description: AWS key pair name for the EC2 instance.
        required: true
      encryption_secret_key:
        description: Encryption Secret Key used to encrypt the rancher backups
        required: true
      qase_api_token:
        description: Qase API token to use for Qase reporting
        required: true

    inputs:
      rancher_version:
        description: Rancher Manager version
        type: string
        required: true
      upstream_cluster_version:
        description: Rancher (RKE2) version
        default: v1.30.8+rke2r1
        type: string
        required: true
      destroy_runner:
        description: Destroy runner
        default: true
        type: boolean
      rancher_repo:
        description: Rancher Manager repository
        default: https://releases.rancher.com/server-charts/latest
        type: string
        required: true
      qase_run_id:
        description: Qase run ID to use for reporting (e.g. 'auto', 'none', or a valid numeric ID)
        type: string
        default: 'none'
        required: false

env:
  image_id: ami-00eb69d236edcfaf8
  instance_type: t2.2xlarge
  instance_name: backup-restore-e2e-runner
  AWS_ACCESS_KEY_ID: ${{ secrets.aws_access_key }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.aws_secret_key }}
  DEFAULT_REGION: ${{ secrets.aws_region }}
  KEY_NAME: ${{ secrets.key_name }}
  RANCHER_PASSWORD: ${{ secrets.rancher_password }}
  ENCRYPTION_SECRET_KEY: ${{ secrets.encryption_secret_key }}
  RANCHER_VERSION: ${{ inputs.rancher_version }}
  RANCHER_REPO_URL: ${{ inputs.rancher_repo }}
  RKE2_VERSION: ${{ inputs.upstream_cluster_version }}

permissions:
  contents: read
  actions: write

jobs:
  setup:
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.aws_access_key }}
          aws-secret-access-key: ${{ secrets.aws_secret_key }}
          aws-region: ${{ secrets.aws_region }}

      - name: Create S3 Bucket for terraform remote state
        run: |
          bucket_name="backup-restore-terraform-state"
          # Check if the bucket exists
          if ! aws s3api head-bucket --bucket "$bucket_name" --region ${{ secrets.aws_region }} 2>/dev/null; then
            # Create the bucket if it doesn't exist
            aws s3api create-bucket --bucket "$bucket_name" --region ${{ secrets.aws_region }} --create-bucket-configuration LocationConstraint=${{ secrets.aws_region }}
          else
            echo "Bucket $bucket_name already exists, skipping creation."
          fi

  pre-qase:
    needs: [setup]
    runs-on: ubuntu-latest
    env:
      QASE_API_TOKEN: ${{ secrets.qase_api_token }}
      QASE_PROJECT_CODE: RM
    outputs:
      qase_run_description: ${{ steps.qase.outputs.qase_run_description }}
      qase_run_id: ${{ steps.qase.outputs.qase_run_id }}
      qase_run_name: ${{ steps.qase.outputs.qase_run_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version-file: './go.mod'

      - name: Create/Export Qase Run
        id: qase
        env:
          QASE_RUN_NAME: ${{ github.event_name == 'workflow_dispatch' && inputs.rancher_version || github.workflow }}
        run: |
          case ${{ inputs.qase_run_id }} in
            'auto')
              # Define and export URL of GH test run in Qase run description
              GH_RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
              QASE_DESC="${GH_RUN_URL}"
              export QASE_RUN_DESCRIPTION="${QASE_DESC}"

              # Use full rancher version
              QASE_RUN_NAME=$(echo "Automation Observability E2E Rancher=${{ inputs.rancher_version }}, RKE2 Version=${{ inputs.upstream_cluster_version }}" | grep -P '[0-9]+\.[0-9]+\.[0-9]+(-[a-z]+[0-9]+)?' || true)
              # Or workflow name if the full rancher version is not found
              if [ -z "$QASE_RUN_NAME" ]; then
                QASE_RUN_NAME="Automation Observability E2E Rancher=${{ inputs.rancher_version }}, RKE2 Version=${{ inputs.upstream_cluster_version }} | ${{ github.workflow }}"
              fi

              # Create a Qase run, get its ID
              ID=$(make create-qase-run)

              # Export outputs for future use
              echo "qase_run_description=${QASE_DESC}" >> ${GITHUB_OUTPUT}
              echo "qase_run_id=${ID}" >> ${GITHUB_OUTPUT}
              echo "qase_run_name=${QASE_RUN_NAME}" >> ${GITHUB_OUTPUT}

              # Just an info for debugging purposes
              echo -e "Exported values:\nQASE_RUN_ID=${ID}\nQASE_RUN_DESCRIPTION=${QASE_DESC}\nQASE_RUN_NAME=${QASE_RUN_NAME}"
              ;;
            'none')
              echo "qase_run_id=" >> ${GITHUB_OUTPUT}
              echo "### Test not reported in QASE!" >> ${GITHUB_STEP_SUMMARY}
              ;;
            [0-9]*)
              # If the run ID has been specified
              echo "qase_run_id=${{ inputs.qase_run_id }}" >> ${GITHUB_OUTPUT}
              ;;
          esac


  run-functional-e2e-tests:
    needs: [setup, pre-qase]
    runs-on: ubuntu-latest
    env:
      QASE_API_TOKEN: ${{ secrets.qase_api_token }}
      # Adjust to your project code in Qase:
      QASE_PROJECT_CODE: RM
      QASE_RUN_ID: ${{ needs.pre-qase.outputs.qase_run_id }}
      # Needed for qase_ginkgo or Cypress integration if desired
      QASE_REPORT: 1
    continue-on-error: true
    name: Run Functional E2E Tests

    steps:
      - name: Install yq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq  # yq depends on jq
          sudo wget https://github.com/mikefarah/yq/releases/download/v4.30.5/yq_linux_amd64 -O /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.aws_access_key }}
          aws-secret-access-key: ${{ secrets.aws_secret_key }}
          aws-region: ${{ secrets.aws_region }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.8

      - name: Start SSH agent and add private key
        shell: bash
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_KEY" | tr -d '\r' > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
        env:
          SSH_KEY: ${{ secrets.instance_ssh_key }}

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version-file: './go.mod'

      - name: Create artifacts directory
        run: mkdir -p ~/artifacts

      - name: Setup the required configuration files
        id: setup_config
        run: |
          # 1. Rename .example files
          mv "$GITHUB_WORKSPACE/tests/helper/yamls/inputBackupRestoreConfig.yaml.example" \
            "$GITHUB_WORKSPACE/tests/helper/yamls/inputBackupRestoreConfig.yaml"

          mv "$GITHUB_WORKSPACE/tests/helper/yamls/inputClusterConfig.yaml.example" \
            "$GITHUB_WORKSPACE/tests/helper/yamls/inputClusterConfig.yaml"

          # 2. Set Kubernetes version
          yq -i '.clusterspec.spec.kubernetesVersion = "${{ inputs.upstream_cluster_version }}"' \
            "$GITHUB_WORKSPACE/tests/helper/yamls/inputClusterConfig.yaml"

          # 3. Set AWS credentials
          yq -i '.accessKey = "${{ secrets.aws_access_key }}"' \
            "$GITHUB_WORKSPACE/tests/helper/yamls/inputBackupRestoreConfig.yaml"

          yq -i '.secretKey = "${{ secrets.aws_secret_key }}"' \
            "$GITHUB_WORKSPACE/tests/helper/yamls/inputBackupRestoreConfig.yaml"

      - name: Run Backup Restore Functional Tests
        id: go-run-tests
        run: |
          set -o pipefail
          mv $GITHUB_WORKSPACE/cattle-config.yaml.example $GITHUB_WORKSPACE/cattle-config.yaml
          CATTLE_TEST_CONFIG=$GITHUB_WORKSPACE/cattle-config.yaml \
          TEST_LABEL_FILTER=backup-restore \
          go test -timeout 60m github.com/rancher/observability-e2e/tests/backuprestore/functional/ -v -count=1 -ginkgo.v | tee ~/artifacts/test-output-e2e.txt

      - name: Cleanup temporary files
        if: ${{ always() }}
        run: |
          rm -f $GITHUB_WORKSPACE/cattle-config.yaml

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: test-artifacts-functional
          path: ~/artifacts

  post-qase:
    # MODIFIED: This job will now only run if the dependent jobs succeeded or failed, but NOT if they were skipped.
    if: ${{ (success() || failure()) && needs.pre-qase.outputs.qase_run_id != '' }}
    needs: [run-functional-e2e-tests, pre-qase]
    runs-on: ubuntu-latest
    env:
      QASE_API_TOKEN: ${{ secrets.qase_api_token }}
      QASE_PROJECT_CODE: RM
      QASE_REPORT: 1
      QASE_RUN_COMPLETE: 1
      QASE_RUN_ID: ${{ needs.pre-qase.outputs.qase_run_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version-file: './go.mod'

      - name: Finalize Qase Run and publish Results
        if: ${{ always() && !contains(needs.run-e2e.result, 'cancelled') }}
        run: |
          REPORT=$(make publish-qase-run)
          echo "${REPORT}"

          # If your tool prints "Report available: [URL]",
          # parse that here for the summary
          REPORT_URL=$(awk '/available:/ { print $NF }' <<<"${REPORT}")
          if [[ -n "${REPORT_URL}" ]]; then
            echo "## QASE Reporting" >> ${GITHUB_STEP_SUMMARY}
            echo "Public Qase report: ${REPORT_URL}" >> ${GITHUB_STEP_SUMMARY}
          fi

      - name: Delete Qase Run if job cancelled/skipped AND qase_run_id was 'auto'
        if: ${{ always() && (contains(needs.run-e2e.result, 'cancelled') || contains(needs.run-e2e.result, 'skipped')) && inputs.qase_run_id == 'auto' }}
        run: make delete-qase-run


  delete-resources:
    if: ${{ always() && inputs.destroy_runner == true }}
    needs: [setup, run-functional-e2e-tests]
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.aws_access_key }}
          aws-secret-access-key: ${{ secrets.aws_secret_key }}
          aws-region: ${{ secrets.aws_region }}

      - name: Install awsdeleter and clean up AWS resources
        run: |
          sudo apt install -y python3 python3-pip python3-venv
          python3 -m venv awsdeleter-env
          source awsdeleter-env/bin/activate
          python3 -m pip install --no-cache-dir awsdeleter
          prefixes=("auto-okhatavk" "okhatavk" "auto-backup-restore-test" "backup-restore-terraform-state")

          for prefix in "${prefixes[@]}"; do
            for i in {1..10}; do
              if awsdeleter "$prefix" --confirm yes; then
                echo "$prefix: Success on attempt $i"
                break
              else
                echo "$prefix: Attempt $i failed, retrying..."
                sleep 5
              fi
            done
          done
          echo "Deleting S3 state files..."
